;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   I hope you enjoy my heap implementation.
;   Please report any bugs you might encounter.
;
;   Code to test the heap is available in
;   heap-testing.mar
;
;   Please don't forget to put the 
;   heap label at end of file
;
;   Only use:
;       _Malloc
;       _Free
;       __InitializeAllocator (once)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;; heap code start

; This MUST be called for heap to work
; It only needs to be called once
; Initialize allocator
; Set ____heap_total_available
__InitializeAllocator:
    MOV A, 0xF000   ; last address heap can try to occupy
    SUB A, heap
    MOV [____heap_total_available], A
    RET
____heap_total_available: DW 0  ; This data is needed for the heap
____heap_size: DW 0             ; It will not work if removed
;__InitializeAllocator end

; Malloc(void *ptr, int size)
; usage: 
;
;   PUSH ptr        ; Push memory addr of pointer 
;   PUSH [size]     ; Push size to allocate
;   CALL _Malloc    ; [[ptr]] now points to first address of allocated memory
;                   ; You cannot use [[ptr]] directly so you must move it to a register first
;   
;   PUSH pointer
;   PUSH 1
;   CALL _Malloc
;
;   MOV A, [pointer]
;   MOV [A], 5
;
;   Currently if you go over the heap limit things will just sort of not allocate
;   Does not change any registers
_Malloc:
    PUSH BP
    MOV BP, SP
    PUSH A
    PUSH B
    PUSH C
    PUSH D
    PUSH X
    PUSH Y

    MOV D, [BP+2]   ; A is the size we want
    TEST D,D
    JZ ___Malloc_search_not_found      ; Don't waste time malloc(ptr,0)

    ADD D, 2        ; We need to have add room for the control word and the range word

    CMP [____heap_total_available], D
    JC ___Malloc_search_not_found      ; Fail if heap total < requested size

    MOV C, [____heap_size]              ; Get current total allocated
    ADD C, D                        ; Add the new size we want
    JC ___Malloc_search_not_found      ; fail if new size + ____heap_size > 0xFFFF
    CMP [____heap_total_available],C    ; Check if the new total is more than is available
    JC ___Malloc_search_not_found      ; Fail if taking up too much memory

    MOV X, heap     ; X is the heap pointer
    MOV Y, [BP+3]   ; Y is the ptr

___Malloc_search_loop:
    MOV B, [X+1]      ; Get range word at X+1
    ;AND B, 0xFFFF   ; get the amount of allocated space in current address and move to the next one

    TEST [X], [X]  ; if X address is allocated, move on to the next available address
    JNZ ______Malloc_search_loop_continue

    MOV A, X
    CALL __CombineEmptyBlocks

    MOV B, [X+1]    ; Use out possible newly available

    TEST B, B       ; if size hasn't been set, we're good to go
    JZ ___Malloc_search_found_size_zero

    CMP D, B        ; if Our size is less than or equal to the space available, take the spot
    JLE  ___Malloc_search_found_existing

    ADD X, B

    JMP ______Malloc_search_loop_continue

______Malloc_search_loop_continue:
    ADD X, B        ; increment by range word
    JMP ___Malloc_search_loop

___Malloc_search_found_size_zero:
    ADD [____heap_size], D              ; ADD new block our heap size

    JMP ___Malloc_search_found
___Malloc_search_found_existing:
    SUB B, D                        ; Remove our current size from the existing free block
    MOV A, X                        ; Copy address of current control word
    ADD A, D                        ; Mov current size forward to create a new block control word
    MOV [A], B

___Malloc_search_found:
    MOV [X+1], D                    ; Set the range word
    MOV [X], 1                      ; Set the control word
    ADD X,2                         ; Do not send back the allocator control word or the range word
    MOV [Y], X                      ; Send back the allocated memory address

    JMP ___Malloc_done

___Malloc_search_not_found:
    MOV [Y], 0      ; We could not alloc, sad day

___Malloc_done:
    POP Y
    POP X
    POP D
    POP C
    POP B
    POP A
    POP BP
    RET 2   ; we pushed 2 things to call
;_Malloc end

; free(void *ptr)
; usage:
;
;   PUSH pointer    ; Push address of pointer
;   CALL _Free      ; If successful [pointer] will now be zero
;                   ; If you tried to free something outside of the heap
;                   ; It will remain as it was
;
; Does not change any registers
_Free:
    PUSH BP
    MOV BP, SP
    PUSH A
    PUSH B
    PUSH C
    PUSH Y

    MOV Y, [BP+2]   ; [Y] is ptr
    MOV X, [Y]      ; X is the location Y is pointing at

    TEST X,X
    JZ ___Free_done    ; if X is 0 we don't need to do anything

    CMP X, heap    ; if X is less than the heap starting point, this is not ours
    JLE ___Free_done

    MOV C, [____heap_size]
    ADD C, heap     ; add heap address and ____heap_size to get to the end of the heap
    CMP C,X        ; if X is greater than the heap ending point, this is not ours
    JC  ___Free_done
    
    MOV [X-2], 0        ; Unset the control word

    MOV A, [X]          ; Set the data in this block
    MOV B, 0            ; Fill it with zeros, except for the control word
    MOV C, [X-1]        ; Go as far as the range specified in range word - 2
    SUB C, 2
    CALL __Memset

    MOV [Y], 0      ; Set pointer to nil

___Free_done:
    POP Y
    POP C
    POP B
    POP A
    POP BP
    RET 1
;_Free end

; Combines empty blocks for found during malloc
__CombineEmptyBlocks:
    PUSH C
    PUSH D

    MOV C, A

___CombineEmptyBlocks_loop:
    TEST [C], [C]        ; If the current control block is allocated, stop if so
    JNZ ___CombineEmptyBlocks_done

    TEST [C+1], [C+1]           ; Check if the current range word is zero
    JZ ___CombineEmptyBlocks_zero

    MOV D, C                    ; Hold on to current control word
    ADD D, [C+1]                ; Get to next control word
    MOV [C], 0                    ; Clear this control word

    ADD [A+1], [C+1]            ; Current block is free to add it's size onto A

    MOV [C+1], 0                ; Clear this block's size
    MOV C,D                     ; Move on to next control word
    JMP ___CombineEmptyBlocks_loop

___CombineEmptyBlocks_zero:
    SUB [____heap_size], [A+1]      ; We are at the end, this is no longer part of the heap
    MOV [A], 0                  ; If we came across a completely unset control bit
    MOV [A+1],0                 ; we must be at the end of the allocated section
___CombineEmptyBlocks_done:     ; of the heap
    POP D
    POP C
    RET
;__CombineEmptyBlocks end

; void * memset ( void * ptr, int value, size_t num );
;
;   MOV A, dest
;   MOV B [value]
;   MOV B [size]
;   CALL __Memset
;
__Memset:
    PUSH A
    PUSH B
    PUSH C

    ADD C, A
___memset_loop:
    MOV [A], B
    ADD A, 1
    CMP A, C
    JL ___memset_loop

    POP C
    POP B
    POP A
    RET
;__Memset end

;;;;; heap code end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;   MUST BE AT END OF FILE
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

heap: DW 0